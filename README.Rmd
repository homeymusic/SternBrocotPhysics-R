---
title: "Stern-Brocot Physics"
output:
  github_document: default
---
```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = here::here())
library("ggplot2")
knitr::opts_chunk$set(fig.showtext = TRUE, dpi = 300)
```

```{r build-and-load, echo=F, message=F, include=F}
# Rebuild the package and load it into the environment
pkgbuild::compile_dll() 
devtools::load_all(".")

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  warning = FALSE,
  message = FALSE,
  fig.crop = TRUE
)
manuscript_dir <- here::here("manuscript")
```

```{r jump-detection, echo=F}
# 1. Load Summary
summary_path <- here::here("data-raw", "outputs", "02_aggregated_summary", "02_aggregated_summary.csv.gz")
dt_summary <- data.table::fread(summary_path)
data.table::setorder(dt_summary, momentum)

dt_summary <- dt_summary[momentum > 0.0]

# 2. Sensitivity-based Jump Detection
# Now working only with the physical data range
z_diffs <- abs(diff(dt_summary$zurek_entropy_median))
threshold <- max(z_diffs, na.rm = TRUE) * 0.0001
jump_indices <- which(z_diffs > threshold)

# 3. Dynamic Build with Integer Plateau logic
jumps <- lapply(seq_along(jump_indices), function(i) {
  idx <- jump_indices[i]
  m_at <- dt_summary$momentum[idx + 1]
  # Logic: Plateau below at floor - 0.1, Plateau above at ceiling + 0.1
  list(
    n = paste("Transition", i),
    p_vals = c(
      m_at-1,
      m_at,       
      m_at+1
      # floor(m_at),
      # m_at,       
      # ceiling(m_at)
    )
  )
})

p_markers <- dt_summary$momentum[jump_indices]
```

```{r introduction, child = 'inst/readme/introduction.Rmd'}
```
### Fit Statistics: Holographic Theory ($S ~ \sqrt{P}$)

The quantitative analysis of the physical data ($P \ge 1.0$) provides strong evidence that the **Zurek entropy** best aligns with the hypothesized **holographic principle** scaling.

```{r fit-statistics, echo=FALSE}
# 1. Define Helper Function
calculate_fit_stats <- function(metric_name, data_summary) {
  mean_col <- paste0(metric_name, "_mean")
  if (!(mean_col %in% names(data_summary))) return(NULL)
  
  plot_dt <- data_summary[momentum >= 1.0, .(
    momentum = as.numeric(momentum),
    y_mean   = as.numeric(get(mean_col))
  )]
  
  if (nrow(plot_dt) == 0) return(NULL)
  
  k_fit <- mean(plot_dt$y_mean / sqrt(plot_dt$momentum), na.rm = TRUE)
  theory <- k_fit * sqrt(plot_dt$momentum)
  
  ss_total <- sum((plot_dt$y_mean - mean(plot_dt$y_mean))^2)
  ss_residual <- sum((plot_dt$y_mean - theory)^2)
  
  return(list(
    Metric = metric_name,
    Label = tools::toTitleCase(gsub("_", " ", metric_name)),
    k_constant = round(k_fit, 3),
    R_squared = round(1 - (ss_residual / ss_total), 4),
    Correlation_R = round(cor(plot_dt$y_mean, theory), 4),
    RMSE = round(sqrt(mean((plot_dt$y_mean - theory)^2)), 4)
  ))
}

# 2. Generate Stats Table
metric_titles <- c(
  "zurek_entropy"        = "Total Entropy S = K + H",
  "kolmogorov_complexity" = "Kolmogorov Complexity K",
  "shannon_entropy"      = "Shannon Entropy H"
)

target_metrics <- names(metric_titles)
stats_list <- lapply(target_metrics, calculate_fit_stats, data_summary = dt_summary)
names(stats_list) <- target_metrics
stats_df <- as.data.frame(do.call(rbind, stats_list))

# 3. Render Table
knitr::kable(stats_df[, -1], row.names = FALSE)
```

The Zurek and Kolmogorov complexity metrics both exhibit outstanding fits to the theory curve. In contrast, the Shannon entropy metric yields a very poor fit, confirming it is likely the source of the structured, "quantized" deviations.

```{r plot-all-metrics-with-residuals, fig.width=8, fig.height=8, echo=FALSE, results='asis'}
render_dual_plot <- function(metric_name, data_summary, transition_markers, m_stats) {
  
  clean_title <- metric_titles[metric_name]
  
  plot_dt <- data_summary[momentum >= 1.0, .(
    momentum = as.numeric(momentum),
    y_mean   = as.numeric(get(paste0(metric_name, "_mean"))),
    y_med    = as.numeric(get(paste0(metric_name, "_median"))),
    y_sd     = as.numeric(get(paste0(metric_name, "_sd")))
  )]

  k_val <- m_stats$k_constant
  r_val <- m_stats$Correlation_R
  plot_dt[, theory := k_val * sqrt(momentum)]
  plot_dt[, residuals := y_mean - theory]

  p_main <- ggplot(plot_dt, aes(x = momentum)) +
    geom_vline(xintercept = transition_markers[transition_markers >= 1.0], 
               color = "grey70", linetype = "dashed", alpha = 0.5) +
    geom_ribbon(aes(ymin = y_mean - y_sd, ymax = y_mean + y_sd), fill = "gray60", alpha = 0.1) +
    geom_line(aes(y = y_mean, color = "Mean"), linewidth = 1) +
    geom_line(aes(y = y_med, color = "Median"), linewidth = 1) +
    geom_line(aes(y = theory, color = "Holographic Theory"), 
              linewidth = 0.8, alpha = 0.8, linetype = "dashed") +
    scale_color_manual(values = c("Mean" = "gray40", "Median" = "black", "Holographic Theory" = "gray60")) +
    labs(
      title = paste(clean_title, "vs. Normalized Momentum P"),
      subtitle = bquote("Holographic Scaling:" ~ sqrt(P) ~ "(" * k == .(k_val) * "," ~ r == .(r_val) * ")"),
      x = latex2exp::TeX("$P = p / \\sqrt{(m h \\omega) / 2\\pi}$"),
      y = "Entropy [bits]",
      color = "Series"
    ) +
    theme_minimal() +
    theme(legend.position = "bottom", axis.text.x = element_blank())  
  
  p_residuals <- ggplot(plot_dt, aes(x = momentum, y = residuals)) +
    geom_bar(stat = "identity", fill = "gray50", alpha = 0.6) +
    geom_hline(yintercept = 0, color = "gray60", linetype = "solid", linewidth = 1) +
    labs(y = "Residual", x = "Momentum (P)") +
    theme_minimal()

  return(cowplot::plot_grid(p_main, p_residuals, ncol = 1, align = "v", rel_heights = c(3, 1)))
}

for (metric in target_metrics) {
  if (paste0(metric, "_mean") %in% names(dt_summary)) {
    p_final <- render_dual_plot(metric, dt_summary, p_markers, stats_list[[metric]])
    
    ggplot2::ggsave(
      filename = file.path(manuscript_dir, sprintf("%s.pdf", metric)),
      plot = p_final, width = 8, height = 8, device = "pdf"
    )
    print(p_final)
  }
}
```

```{r jump-fluctuations, fig.width=10, fig.height=3 * length(jumps), echo=FALSE}

# 1. Setup list for plots
plot_list <- vector("list", length(jumps) * 3)
counter   <- 1

# 2. Execution Loop
for (j in seq_along(jumps)) {
  for (p in seq_along(jumps[[j]]$p_vals)) {
    
    current_p <- jumps[[j]]$p_vals[p]
    f_name    <- sprintf("micro_macro_erasures_P_%013.6f.csv.gz", round(current_p, 6))
    f_path    <- here::here("data-raw", "outputs", "01_micro_macro_erasures", f_name)
    
    momentum <- current_p
    length   <- momentum
    action   <- length * momentum

    if (file.exists(f_path) && current_p >= 1.0) {
      raw_fluc <- data.table::fread(f_path, select = "fluctuation")$fluctuation * action
      f_range  <- range(raw_fluc, na.rm = TRUE)
      
      # Use range indices for seq()
      panel_breaks <- seq(from = f_range[1], to = f_range[2], length.out = 402)
      h <- graphics::hist(raw_fluc, breaks = panel_breaks, plot = FALSE)
      
      # Dataframe for plotting
      plot_df <- data.frame(
        x = h$breaks[-length(h$breaks)], 
        y = h$counts
      )
      
      p_obj <- ggplot2::ggplot(plot_df, ggplot2::aes(x = x, y = y)) +
        ggplot2::geom_ribbon(
          ggplot2::aes(ymin = 0, ymax = y), 
          fill = "black", 
          alpha = 0.3, 
          color = NA
        ) +
        ggplot2::geom_step(direction = "hv", color = "black", linewidth = 0.2) +
        ggplot2::labs(
          title = paste0(jumps[[j]]$n, " at P = ", round(current_p, 2)),
          x = "q",
          y = ""
        ) +
        ggplot2::theme_minimal() +
        ggplot2::theme(plot.title = ggplot2::element_text(size = 10))
      
    } else {
      p_obj <- ggplot2::ggplot() + 
        ggplot2::annotate("text", x = 0.5, y = 0.5, 
                          label = paste("P =", current_p, "\n excluded")) +
        ggplot2::theme_void()
    }
    plot_list[[counter]] <- p_obj
    counter <- counter + 1
  }
}

# 3. Assemble Grid
combined_plot <- patchwork::wrap_plots(plot_list, ncol = 3) + 
  patchwork::plot_annotation(
    title = "Automated Detection of Transition Phases (P >= 1.0)",
    subtitle = "LOWER PLATEAU                      JUMP POINT                      UPPER PLATEAU",
    theme = ggplot2::theme(
      plot.title = ggplot2::element_text(hjust = 0.5, face = "bold", size = 14),
      plot.subtitle = ggplot2::element_text(hjust = 0.5, size = 10, face = "bold")
    )
  )

combined_plot

ggplot2::ggsave(
  filename = file.path(manuscript_dir, "distributions_at_transitions.pdf"),
  plot = combined_plot, 
  width = 10, 
  height = 3 * length(jumps)
)


```

```{r setup-custom-height, echo=FALSE}
# --- CONFIGURATION ---
max_rows <- 7
subset_jumps <- if(length(jumps) > max_rows) jumps[1:max_rows] else jumps
n_rows <- length(subset_jumps)

# Calculate the height needed for the next chunk
dynamic_height <- 3 * n_rows
```

```{r distriubtions-for-manuscript, fig.width=10, fig.height=dynamic_height, echo=FALSE}

# 1. Setup list for plots
plot_list <- vector("list", n_rows * 3)
counter   <- 1

# 2. Execution Loop
for (j in seq_len(n_rows)) {
  for (p in seq_along(subset_jumps[[j]]$p_vals)) {
    
    current_p <- subset_jumps[[j]]$p_vals[p]
    f_name    <- sprintf("micro_macro_erasures_P_%013.6f.csv.gz", round(current_p, 6))
    f_path    <- here::here("data-raw", "outputs", "01_micro_macro_erasures", f_name)
    
    momentum <- current_p
    length   <- momentum
    action   <- length * momentum
    
    if (file.exists(f_path) && current_p >= 1.0) {
      raw_fluc <- data.table::fread(f_path, select = "fluctuation")$fluctuation * action
      f_range  <- range(raw_fluc, na.rm = TRUE)
      panel_breaks <- seq(from = f_range[1], to = f_range[2], length.out = 402)
      h <- graphics::hist(raw_fluc, breaks = panel_breaks, plot = FALSE)
      
      plot_df <- data.frame(x = h$breaks[-length(h$breaks)], y = h$counts)
      
      p_obj <- ggplot2::ggplot(plot_df, ggplot2::aes(x = x, y = y)) +
        ggplot2::geom_ribbon(ggplot2::aes(ymin = 0, ymax = y), fill = "black", alpha = 0.3) +
        ggplot2::geom_step(direction = "hv", color = "black", linewidth = 0.2) +
        ggplot2::labs(title = paste0(subset_jumps[[j]]$n, " at P = ", round(current_p, 2)),
                      x = "q", y = "") +
        ggplot2::theme_minimal()
    } else {
      p_obj <- ggplot2::ggplot() + 
        ggplot2::annotate("text", x = 0.5, y = 0.5, label = paste("P =", current_p, "\n excluded")) +
        ggplot2::theme_void()
    }
    plot_list[[counter]] <- p_obj
    counter <- counter + 1
  }
}

# 3. Assemble and Print Grid
combined_plot <- patchwork::wrap_plots(plot_list, ncol = 3) + 
  patchwork::plot_annotation(
    title = "Automated Detection of Transition Phases (P >= 1.0)",
    subtitle = "LOWER PLATEAU                      JUMP POINT                      UPPER PLATEAU"
  )

combined_plot

# 4. Save
ggplot2::ggsave(
  filename = file.path(manuscript_dir, "distributions.pdf"),
  plot = combined_plot, width = 10, height = dynamic_height
)
```

```{r plot-complexity-vs-denominator, fig.width=8, fig.height=6, echo=FALSE}
# 1. Assign to a variable
p_scatter <- ggplot(dt_summary, aes(x = shannon_entropy_mean, y = kolmogorov_complexity_mean, color = momentum)) +
  geom_point(alpha = 0.7, size = 0.05) +
  scale_color_gradient(low = "gray20", high = "gray80") + 
  labs(
    title = "Scatter Plot: Shannon Entropy vs. Kolmogorov Complexity (P >= 1.0)",
    x = "Mean Shannon Entropy",
    y = "Mean Kolmogorov Complexity",
    color = "Momentum (P)"
  ) +
  theme_minimal()

# 2. Save it using the path that worked for you
ggplot2::ggsave(
  filename = file.path(manuscript_dir, "entropy_vs_complexity.pdf"),
  plot = p_scatter, 
  width = 8, 
  height = 6,
  device = "pdf"
)

# 3. Display it in the Rmd
p_scatter
```
