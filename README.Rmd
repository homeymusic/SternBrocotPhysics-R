---
title: "Stern-Brocot Physics"
output:
  github_document: default
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = here::here())
knitr::opts_chunk$set(fig.showtext = TRUE, dpi = 300)
library(ggplot2)
library(ggforce)
library(dplyr)
library(tidyr)
```

```{r build-and-load, echo=F, message=F, include=F}
# Rebuild the package and load it into the environment
pkgbuild::compile_dll() 
devtools::load_all(".")

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  warning = FALSE,
  message = FALSE,
  fig.crop = TRUE
)
manuscript_dir <- here::here("manuscript")
```

```{r jump-detection, echo=F}
# 1. Load Summary
summary_path <- here::here("data-raw", "outputs", "02_aggregated_summary", "02_aggregated_summary.csv.gz")
dt_summary <- data.table::fread(summary_path)
data.table::setorder(dt_summary, momentum)

dt_summary <- dt_summary[momentum > 0.0]

# 2. Sensitivity-based Jump Detection
# Now working only with the physical data range
z_diffs <- abs(diff(dt_summary$kolmogorov_complexity_median))
threshold <- max(z_diffs, na.rm = TRUE) * 0.0001
jump_indices <- which(z_diffs > threshold)

# 3. Dynamic Build with Integer Plateau logic
jumps <- lapply(seq_along(jump_indices), function(i) {
  idx <- jump_indices[i]
  m_at <- dt_summary$momentum[idx + 1]
  # Logic: Plateau below at floor - 0.1, Plateau above at ceiling + 0.1
  list(
    n = paste("Transition", i),
    p_vals = c(
      m_at-1,
      m_at,       
      m_at+1
      # floor(m_at),
      # m_at,       
      # ceiling(m_at)
    )
  )
})

p_markers <- dt_summary$momentum[jump_indices]
```

```{r introduction, child = 'inst/readme/introduction.Rmd'}
```

```{r landauer-analysis, echo=FALSE}
plot_dt <- dt_summary[momentum >= 1.0, .(
  momentum = as.numeric(momentum),
  y_mean   = as.numeric(kolmogorov_complexity_mean),
  y_med    = as.numeric(kolmogorov_complexity_median),
  y_sd     = as.numeric(kolmogorov_complexity_sd)
)]
```
```{r plot-landauer-squeeze, echo=FALSE}
# 1. Coordinate Transformation
plot_dt[, delta_q := 1 / momentum]

# 2. Dynamic Bounds (Filtered to visible X-range)
q_range <- range(plot_dt$delta_q, na.rm = TRUE)

# Find Y-range ONLY for points where delta_q is within our q_range
visible_data <- plot_dt[delta_q >= q_range[1] & delta_q <= q_range[2]]
y_range <- range(c(visible_data$y_mean + visible_data$y_sd, 
                   visible_data$y_mean - visible_data$y_sd), na.rm = TRUE)

# Calculate spans and a landscape-biased ratio
q_span <- diff(q_range)
y_span <- diff(y_range)

# Force a landscape aspect ratio: Height is 50% of Width unless data is very tall
# This prevents the "too much vertical space" issue
data_aspect_ratio <- pmin(0.5, y_span / q_span) 

# 3. Visualization
norm_q_title <- latex2exp::TeX("Normalized Coordinate Uncertainty $\\Delta Q = 2/P$ \\[$q_0$\\]")
plot_title <- latex2exp::TeX("Landauer Action $A_L$ vs. Coordinate Uncertainty $\\Delta Q$")

p_main <- ggplot(plot_dt, aes(x = delta_q)) +
  geom_vline(xintercept = 1/p_markers, color = "grey70", linetype = "dashed", alpha = 0.5) +
  geom_ribbon(aes(ymin = y_mean - y_sd, ymax = y_mean + y_sd), fill = "gray50", alpha = 0.1) +
  geom_line(aes(y = y_mean, color = "A Mean"), linewidth = 1) +
  geom_line(aes(y = y_med, color = "A Median"), linewidth = 1) +
  scale_color_manual(values = c("A Mean" = "gray30", "A Median" = "black")) +
  scale_x_reverse(breaks = seq(0, 1, by = 0.2), expand = c(0.02, 0.02)) + 
  labs(title = plot_title, x = norm_q_title, y = "Action $A_L$", color = "Series") +
  theme_minimal() + 
  theme(
    legend.position = "bottom",
    aspect.ratio = data_aspect_ratio, # This makes it "wider than tall"
    axis.title.x = element_text(margin = margin(t = 10))
  ) +
  # coord_cartesian "zooms" into the data-heavy area
  coord_cartesian(xlim = q_range, ylim = y_range, expand = FALSE, clip = "off")

# 4. Save
ggplot2::ggsave(
  filename = file.path(manuscript_dir, "landauer_squeeze.pdf"),
  plot = p_main, 
  width = 8, 
  height = (8 * data_aspect_ratio) + 1, 
  device = grDevices::cairo_pdf
)

print(p_main)
```
```{r distribution-helper, echo=FALSE}
# --- CORE PLOTTING FUNCTION ---
generate_physics_grid <- function(jumps_subset) {
  
  find_nodes_outward <- function(df, scan_direction = "right") {
    empty_result <- data.frame(x = numeric(0), y = numeric(0))
    if (is.null(df) || nrow(df) < 2) return(empty_result)
    
    df <- if(scan_direction == "right") df[order(df$x), ] else df[order(-df$x), ]
    
    h_max <- max(df$y, na.rm = TRUE)
    h_min <- min(df$y, na.rm = TRUE)
    h_range <- h_max - h_min
    h_avg   <- mean(df$y, na.rm = TRUE)

    thresh <- 1 / (4 * pi)
    if (h_range < (thresh * h_avg)) return(empty_result)

    reset_val <- 0 
    nodes <- empty_result; ready_to_fire <- TRUE; cumulative_rise <- 0  
    
    for (i in seq_len(nrow(df) - 1)) {
      local_change <- (df$y[i+1] - df$y[i]) / h_range
      if (ready_to_fire) {
        cumulative_rise <- cumulative_rise + local_change
        if (cumulative_rise >= thresh) {
          nodes <- rbind(nodes, df[i+1, c("x", "y")])
          ready_to_fire <- FALSE; cumulative_rise <- 0 
        }
        if (local_change < 0) cumulative_rise <- 0
      } else {
        if (local_change <= reset_val) ready_to_fire <- TRUE
      }
    }
    return(nodes)
  }

  num_jumps <- length(jumps_subset); plot_list <- vector("list", num_jumps * 3); counter <- 1

  for (j in seq_len(num_jumps)) {
    for (p in seq_along(jumps_subset[[j]]$p_vals)) {
      current_p <- jumps_subset[[j]]$p_vals[p]
      f_name    <- sprintf("micro_macro_erasures_P_%013.6f.csv.gz", round(current_p, 6))
      f_path    <- here::here("data-raw", "outputs", "01_micro_macro_erasures", f_name)
      action    <- current_p * current_p

      if (file.exists(f_path) && current_p >= 1.0) {
        raw_fluc <- data.table::fread(f_path, select = "fluctuation")$fluctuation * action
        f_range  <- range(raw_fluc, na.rm = TRUE)
        panel_breaks <- seq(from = f_range[1], to = f_range[2], length.out = 402)
        h <- graphics::hist(raw_fluc, breaks = panel_breaks, plot = FALSE)
        plot_df <- data.frame(x = h$mids, y = h$counts)
        
        # 1. Scans with Significance Filter
        dots_r <- find_nodes_outward(plot_df[plot_df$x >= 0, ], "right")
        dots_l <- find_nodes_outward(plot_df[plot_df$x < 0, ], "left")
        
        # 2. Bimodal/Trough Unification
        if(nrow(dots_r) > 0 && nrow(dots_l) > 0) {
          inner_l <- dots_l[which.max(dots_l$x), ]; inner_r <- dots_r[which.min(dots_r$x), ]
          y_center <- plot_df$y[which.min(abs(plot_df$x))]
          if(y_center <= inner_l$y && y_center <= inner_r$y) {
            center_dot <- data.frame(x = 0, y = y_center)
            dot_df <- rbind(center_dot, dots_l[dots_l$x < inner_l$x, ], dots_r[dots_r$x > inner_r$x, ])
          } else {
            dot_df <- rbind(dots_l, dots_r)
          }
        } else {
          dot_df <- rbind(dots_l, dots_r)
        }
        
        dot_df <- unique(dot_df[complete.cases(dot_df), ])
        node_count <- nrow(dot_df)
        p_obj <- ggplot2::ggplot(plot_df, ggplot2::aes(x = x, y = y)) +
          ggplot2::geom_ribbon(ggplot2::aes(ymin = 0, ymax = y), fill = "black", alpha = 0.3) +
          ggplot2::geom_step(direction = "hv", color = "black", linewidth = 0.2) +
          ggplot2::geom_point(data = dot_df, color = "red", size = 1.2) +           
          ggplot2::labs(
            title = paste0(jumps_subset[[j]]$n, " # of Nodes: ", node_count, " at P = ", sprintf("%.2f", current_p)), 
            x = "q", y = ""
          ) +
          ggplot2::theme_minimal() +
          ggplot2::theme(plot.title = ggplot2::element_text(size = 10))
      } else {
        p_obj <- ggplot2::ggplot() + 
          ggplot2::annotate("text", x = 0.5, y = 0.5, label = paste("P =", sprintf("%.2f", current_p), "\n excluded")) +
          ggplot2::theme_void()
      }
      plot_list[[counter]] <- p_obj; counter <- counter + 1
    }
  }

  patchwork::wrap_plots(plot_list, ncol = 3) + 
    patchwork::plot_annotation(
      title = "Automated Detection of Median Momentum Transitions",
      subtitle = "HYSTERESIS WITH NOISE-SIGNAL SIGNIFICANCE FILTERING",
      theme = ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, face = "bold", size = 14))
    )
}


```

```{r jump-fluctuations, fig.width=10, fig.height=3 * length(jumps), echo=FALSE}
# 1. Full call for Readme
full_plot <- generate_physics_grid(jumps)
full_plot
```
```{r subset-config, echo=FALSE}
# --- SINGLE SOURCE OF TRUTH ---
max_rows      <- 7 
subset_idx    <- 1:min(length(jumps), max_rows)
subset_jumps  <- jumps[subset_idx]
dynamic_h     <- 3 * length(subset_jumps)
```

```{r distributions-for-manuscript, fig.width=10, fig.height=dynamic_h, echo=FALSE}
# Now fig.height is dynamically tied to the actual number of rows
subset_plot <- generate_physics_grid(subset_jumps)

# Display in the Readme
subset_plot

# Save PDF with exact same dimensions
ggplot2::ggsave(
  filename = file.path(manuscript_dir, "distributions.pdf"),
  plot   = subset_plot, 
  width  = 10, 
  height = dynamic_h
)
```

# Ellipse Parameterization (A = PQ)

This visualization shows two overlapping ellipses centered at (0,0) where $A = PQ$. 

```{r experimental_ellipses, fig.width=10, fig.height=3 * length(jumps), echo=FALSE}
# 1. Extract and format labels with 2-decimal precision
ellipse_data <- lapply(jumps, function(j) {
  data.frame(
    transition_name = j$n,
    P_value = j$p_vals,
    Q_value = j$p_vals,
    p_label = factor(sprintf("P = Q = %.2f", j$p_vals), 
                     levels = sprintf("P = Q = %.2f", j$p_vals))
  )
}) %>% bind_rows()

# 2. Calculate radii and axis limits
plot_ready <- ellipse_data %>%
  mutate(
    q_radius_x = Q_value,
    q_radius_y = 1/P_value,
    p_radius_x = 1/Q_value,
    p_radius_y = P_value,
    lim = pmax(q_radius_x, p_radius_y) * 1.1 
  ) %>%
  pivot_longer(
    cols = starts_with("q_radius") | starts_with("p_radius"),
    names_to = c("ellipse_type", ".value"),
    names_pattern = "(.*)_radius_(.*)"
  )

# 3. Generate the plot object
ellipse_plot <- ggplot(plot_ready) +
  # Reduced linewidth for better resolution at high P, Q values
  geom_ellipse(aes(x0 = 0, y0 = 0, a = x, b = y, angle = 0, 
                   fill = ellipse_type, color = ellipse_type), 
               linewidth = 0.2, alpha = 0.5) +
  geom_blank(aes(x = lim, y = lim)) +
  geom_blank(aes(x = -lim, y = -lim)) +
  facet_wrap(transition_name ~ p_label, 
             scales = "free", 
             ncol = 3) +
  scale_fill_manual(values = c("q" = "black", "p" = "gray40"),
                    labels = c("q" = "Q", "p" = "P")) +
  scale_color_manual(values = c("q" = "black", "p" = "gray40"),
                     labels = c("q" = "Q", "p" = "P")) +
  labs(
    x = "q [q_0]",
    y = "p [p_0]",
    fill = "Conjugate Pair",
    color = "Conjugate Pair",

    
        title = "Conjugate Quanta of Action",
          subtitle = "LOWER PLATEAU, TRANSITION, UPPER PLATEAU",
  ) +
  theme_minimal() +
  theme(
    aspect.ratio = 1,
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 8)
  )

# Print the plot to the Rmd output
ellipse_plot

# 4. Save the plot to the manuscripts directory
num_transitions <- length(unique(ellipse_data$transition_name))
dynamic_h <- num_transitions * 3

ggplot2::ggsave(
  filename = here::here(manuscript_dir, "conjugate_quanta.pdf"),
  plot   = ellipse_plot, 
  width  = 10, 
  height = dynamic_h
)
```
