---
title: "Stern-Brocot Physics"
output:
  github_document: default
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = here::here())
knitr::opts_chunk$set(fig.showtext = TRUE, dpi = 300)
library(ggplot2)
library(patchwork)
library(ggforce)
library(dplyr)
library(tidyr)
```

```{r build-and-load, echo=F, message=F, include=F}
# Rebuild the package and load it into the environment
pkgbuild::compile_dll() 
devtools::load_all(".")

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  warning = FALSE,
  message = FALSE,
  fig.crop = TRUE
)
manuscript_dir <- here::here("manuscript")
```

```{r jump-detection, echo=F}
# 1. Load Summary
summary_path <- here::here("data-raw", "outputs", "02_aggregated_summary", "02_aggregated_summary.csv.gz")
dt_summary <- data.table::fread(summary_path)
data.table::setorder(dt_summary, momentum)

dt_summary <- dt_summary[momentum > 0.0]

# 2. Sensitivity-based Jump Detection
# Now working only with the physical data range
z_diffs <- abs(diff(dt_summary$kolmogorov_complexity_median))
threshold <- max(z_diffs, na.rm = TRUE) * 0.0001
jump_indices <- which(z_diffs > threshold)

# 3. Dynamic Build with Integer Plateau logic
jumps <- lapply(seq_along(jump_indices), function(i) {
  idx <- jump_indices[i]
  m_at <- dt_summary$momentum[idx + 1]
  # Logic: Plateau below at floor - 0.1, Plateau above at ceiling + 0.1
  list(
    n = paste("Transition", i),
    p_vals = c(
      m_at-1,
      m_at,       
      m_at+1
      # floor(m_at),
      # m_at,       
      # ceiling(m_at)
    )
  )
})

p_markers <- dt_summary$momentum[jump_indices]
```

```{r introduction, child = 'inst/readme/introduction.Rmd'}
```

```{r dual-aspect-complexity, echo=FALSE, fig.width=12, fig.height=6}
# 1. Data Preparation
plot_dt_q <- dt_summary[momentum > 0.0, .(
  q_val  = 1 / as.numeric(momentum),
  y_mean = as.numeric(kolmogorov_complexity_mean),
  y_med  = as.numeric(kolmogorov_complexity_median),
  y_sd   = as.numeric(kolmogorov_complexity_sd)
)]

plot_dt_p <- dt_summary[momentum > 0.0, .(
  p_val  = as.numeric(momentum),
  y_mean = as.numeric(kolmogorov_complexity_mean),
  y_med  = as.numeric(kolmogorov_complexity_median),
  y_sd   = as.numeric(kolmogorov_complexity_sd)
)]

# 2. Plot A: K(Q_0) vs. Q
# Updated Plot A: K(Q_0) vs. Q with Log Scaling
p_spatial <- ggplot(plot_dt_q, aes(x = q_val)) +
  geom_vline(xintercept = 1/p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_ribbon(aes(ymin = y_mean - y_sd, ymax = y_mean + y_sd), fill = "gray50", alpha = 0.1) +
  geom_line(aes(y = y_mean, color = "Mean"), linewidth = 0.6) +
  geom_line(aes(y = y_med, color = "Median"), linewidth = 1.0) +
  scale_x_log10() +  # Added for log scaling
  scale_color_manual(values = c("Mean" = "gray60", "Median" = "black")) +
  labs(
    title = latex2exp::TeX("Coordinate Complexity: $K(Q_0)$ vs. $Q$ (Log Scale)"),
    x = latex2exp::TeX("Coordinate $Q = 1/P$ [$q/q_0$]"),
    y = "Complexity [bits]",
    color = "Series"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5))

# 3. Plot B: K(P_0) vs. P
p_momentum <- ggplot(plot_dt_p, aes(x = p_val)) +
  geom_vline(xintercept = p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_ribbon(aes(ymin = y_mean - y_sd, ymax = y_mean + y_sd), fill = "gray50", alpha = 0.1) +
  geom_line(aes(y = y_mean, color = "Mean"), linewidth = 0.6) +
  geom_line(aes(y = y_med, color = "Median"), linewidth = 1.0) + # Highlight jumps
  scale_color_manual(values = c("Mean" = "gray60", "Median" = "black")) +
  labs(
    title = latex2exp::TeX("Momentum Complexity: $K(P_0)$ vs. $P$"),
    x =  latex2exp::TeX("Momentum P [$p/p_0$]"),
    y = "Complexity [bits]",
    color = "Series"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5))

# 4. Layout
combined_blob_plot <- gridExtra::arrangeGrob(
  p_spatial, p_momentum, 
  ncol = 2,
  top = grid::textGrob("Coordinate and Momentum Complexity", 
                       gp = grid::gpar(fontsize = 16, font = 2))
)

# 5. Output and Save
grid::grid.draw(combined_blob_plot)

ggplot2::ggsave(
  filename = file.path(manuscript_dir, "complexity.pdf"),
  plot = combined_blob_plot, 
  width = 12, 
  height = 6,
  device = grDevices::cairo_pdf
)
```

```{r dual-aspect-node-count, echo=FALSE, fig.width=12, fig.height=6}
# 1. Data Preparation
# Aspect A: Spatial Coordinate Q
plot_nodes_q <- dt_summary[momentum > 0.0, .(
  q_val = 1 / as.numeric(momentum),
  nodes = as.numeric(node_count)
)]

# Aspect B: Momentum P
plot_nodes_p <- dt_summary[momentum > 0.0, .(
  p_val = as.numeric(momentum),
  nodes = as.numeric(node_count)
)]

# 2. Plot C: Node Count vs. Q with Log Scaling
p_nodes_spatial <- ggplot(plot_nodes_q, aes(x = q_val, y = nodes)) +
  geom_vline(xintercept = 1/p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_point(size = 0.2, alpha = 0.6, color = "black") +
  scale_x_log10() +  # Added log scaling for the Q axis
  labs(
    title = latex2exp::TeX("Coordinate Node Counts: Nodes vs. $Q$ (Log Scale)"),
    x = latex2exp::TeX("Coordinate $Q = 1/P$ [$q/q_0$]"),
    y = "Node Count [count]"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))


# 3. Plot D: Node Count vs. P
p_nodes_momentum <- ggplot(plot_nodes_p, aes(x = p_val, y = nodes)) +
  geom_vline(xintercept = p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_point(size = 0.2, alpha = 0.6, color = "black") +
  labs(
    title = latex2exp::TeX("Momentum Node Counts: Nodes vs. $P$"),
    x =  latex2exp::TeX("Momentum P  [$p/p_0$]"),
    y = "Node Count [count]"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 4. Layout
combined_nodes_plot <- gridExtra::arrangeGrob(
  p_nodes_spatial, p_nodes_momentum, 
  ncol = 2,
  top = grid::textGrob("Coordinate and Momentum Node Counts", 
                       gp = grid::gpar(fontsize = 16, font = 2))
)

# 5. Output and Save
grid::grid.draw(combined_nodes_plot)

ggplot2::ggsave(
  filename = file.path(manuscript_dir, "nodes.pdf"),
  plot = combined_nodes_plot, 
  width = 12, 
  height = 6,
  device = grDevices::cairo_pdf
)

```
```{r filter-valid-eigenstates, echo=FALSE, fig.width=8, fig.height=6}
# 1. Data Preparation (Your existing P data)
plot_nodes_p <- dt_summary[momentum > 0.0, .(
  p_val = as.numeric(momentum),
  nodes = as.numeric(node_count)
)]

# 2. Define the Physical Filtering Condition
# A data point (n, P) is a valid eigenstate if n = floor(P^(1/4))
# We create a new boolean column 'is_eigenstate' using this exact logic
plot_nodes_p$is_eigenstate <- floor(plot_nodes_p$p_val/pi) == plot_nodes_p$nodes

eigen_momenta <- plot_nodes_p[is_eigenstate == TRUE, .(
  n = as.integer(nodes),
  momentum = p_val
)]
# --- Updated Plotting Block with Improved Physics Titles ---

p_momentum_filtered <- ggplot(plot_nodes_p, aes(x = p_val, y = nodes)) +
  # All Stern-Brocot data points (The "Rational Search")
  geom_point(color = "grey70", size = 0.2, alpha = 0.4) +
  geom_vline(xintercept = p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  
  # The "Snap-to" Eigenstates (The "Resonant Wave States")
  geom_point(data = subset(plot_nodes_p, is_eigenstate == TRUE), 
             color = "red", size = 0.3) +
             
  labs(
    title = latex2exp::TeX("SchrÃ¶dinger Eigenstates (red) Among All Configurations"),
    subtitle = "Eigenstates are vanishingly sparse configurations among expanding possibilities in phase space.",
    x = latex2exp::TeX("Momentum P [$p/p_0$]"),
    y = latex2exp::TeX("Node Count (Coordinate $Q$ Distriubtions)"),
    caption = "Red: Eigenstates | Grey: All Configurations"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10, face = "italic"),
    axis.title = element_text(size = 11)
  )


# 4. Output and Save
print(p_momentum_filtered)

ggplot2::ggsave(
  filename = file.path(manuscript_dir, "eignstates.pdf"),
  plot = p_momentum_filtered, 
  width = 8, 
  height = 6,
  device = grDevices::cairo_pdf
)
```
```{r eigen-distributions-median, echo=FALSE, warning=FALSE, message=FALSE}
# --- 1. CONFIGURATION & SCALING ---
max_rows_to_plot <- 200  # How many quantum numbers (rows) to show
cols_per_row     <- 3

# --- 2. DATA PREPARATION (MEDIAN MOMENTA) ---
eigen_momenta <- plot_nodes_p[is_eigenstate == TRUE, .(
  n = as.integer(nodes),
  momentum = as.numeric(p_val)
)]

# Group by n, sort by momentum, and pick the middle (median) entry
data.table::setorder(eigen_momenta, n, momentum)
eigen_momenta_median <- eigen_momenta[eigen_momenta[, .I[ceiling(.N/2)], by = n]$V1]

# Subset for the plot
subset_eigen <- head(eigen_momenta_median, max_rows_to_plot)

# DYNAMIC HEIGHT: 3 units per row (matches your jumps logic)
dynamic_h_eigen <- ceiling(nrow(subset_eigen) / cols_per_row) * 3
```

```{r plot-eigen-grid, echo=FALSE, fig.width=10, fig.height=dynamic_h_eigen, warning=FALSE, message=FALSE}
# --- 3. GENERATE GRID ---
plot_list <- vector("list", nrow(subset_eigen))

for (i in seq_len(nrow(subset_eigen))) {
  current_n <- subset_eigen$n[i]
  current_p <- subset_eigen$momentum[i]
  
  f_name <- sprintf("histogram_P_%013.6f.csv.gz", round(current_p, 6))
  f_path <- here::here("data-raw", "outputs", "02_aggregated_summary", "histograms", f_name)

  if (file.exists(f_path)) {
    combined_dt <- data.table::fread(f_path)
    hist_data   <- combined_dt[type == "hist"]
    node_data   <- combined_dt[type == "node"]
    b_width     <- if(nrow(hist_data) > 1) diff(hist_data$x[1:2]) else 0.1

    plot_list[[i]] <- ggplot2::ggplot(hist_data, ggplot2::aes(x = x, y = y)) +
      ggplot2::geom_vline(xintercept = 0, color = "grey80", linetype = "dashed", linewidth = 0.4) +
      ggplot2::geom_col(fill = "black", alpha = 0.25, width = b_width) +
      ggplot2::geom_step(direction = "hv", color = "black", linewidth = 0.3) +
      ggplot2::geom_point(data = node_data, color = "black", size = 1.2, shape = 16) +
      ggplot2::labs(
        title = paste0("n = ", current_n, " | P = ", sprintf("%.4f", current_p)), 
        x = "q", y = ""
      ) +
      ggplot2::theme_minimal(base_family = "mono") +
      ggplot2::theme(
        plot.title = ggplot2::element_text(size = 9, face = "bold"),
        panel.grid.minor = ggplot2::element_blank()
      )
  } else {
    plot_list[[i]] <- ggplot2::ggplot() + ggplot2::theme_void()
  }
}

# Assemble with Patchwork
final_plot <- patchwork::wrap_plots(plot_list, ncol = cols_per_row) + 
  patchwork::plot_annotation(
    title = "Median Eigenstate Distributions",
    subtitle = "One representative configuration per quantum number n",
    theme = ggplot2::theme(
      plot.title = ggplot2::element_text(hjust = 0.5, face = "bold", size = 14, family = "mono")
    )
  )

# Display
final_plot

# Save
ggplot2::ggsave(
  filename = file.path(manuscript_dir, "eigen_distributions_median.pdf"),
  plot   = final_plot, 
  width  = 10, 
  height = dynamic_h_eigen,
  device = grDevices::cairo_pdf,
  limitsize = FALSE
)
```



```{r distribution-helper, echo=FALSE}
# --- CORE PLOTTING FUNCTION (OPTIMIZED) ---
generate_physics_grid <- function(jumps_subset) {
  
  num_jumps <- length(jumps_subset)
  plot_list <- vector("list", num_jumps * 3)
  counter   <- 1

  for (j in seq_len(num_jumps)) {
    for (p in seq_along(jumps_subset[[j]]$p_vals)) {
      current_p <- jumps_subset[[j]]$p_vals[p]
      
      # Target the new self-contained histogram files
      f_name <- sprintf("histogram_P_%013.6f.csv.gz", round(current_p, 6))
      f_path <- here::here("data-raw", "outputs", "02_aggregated_summary", "histograms", f_name)

      if (file.exists(f_path)) {
        # 1. Read the pre-computed data
        combined_dt <- data.table::fread(f_path)
        
        # 2. Extract metadata and split data
        node_label <- as.character(combined_dt$node_count[1])
        hist_data  <- combined_dt[type == "hist"]
        node_data  <- combined_dt[type == "node"]
        
        # Calculate bin width for gap-free bars
        b_width <- if(nrow(hist_data) > 1) diff(hist_data$x[1:2]) else 0.1

        # 3. Generate High-Fidelity Plot
        p_obj <- ggplot2::ggplot(hist_data, ggplot2::aes(x = x, y = y)) +
          # Physics reference line
          ggplot2::geom_vline(xintercept = 0, color = "grey80", linetype = "dashed", linewidth = 0.4) +
          # Gap-free stepped area
          ggplot2::geom_col(fill = "black", alpha = 0.25, width = b_width) +
          # Sharp staircase outline
          ggplot2::geom_step(direction = "hv", color = "black", linewidth = 0.3) +
          # Pre-computed red nodes
          ggplot2::geom_point(data = node_data, color = "black", size = 1.2, shape = 16) +
          ggplot2::labs(
            title = paste0(jumps_subset[[j]]$n, " Nodes: ", node_label, " at P = ", sprintf("%.2f", current_p)), 
            x = "q", y = ""
          ) +
          ggplot2::theme_minimal(base_family = "mono") +
          ggplot2::theme(
            plot.title = ggplot2::element_text(size = 9, face = "bold"),
            panel.grid.minor = ggplot2::element_blank()
          )
      } else {
        # Placeholder for missing momentum values
        p_obj <- ggplot2::ggplot() + ggplot2::theme_void() + 
          ggplot2::annotate("text", x = 0.5, y = 0.5, 
                            label = paste("P =", sprintf("%.2f", current_p), "\n missing"),
                            family = "mono", size = 3)
      }
      
      plot_list[[counter]] <- p_obj
      counter <- counter + 1
    }
  }

  # Assemble the grid
  patchwork::wrap_plots(plot_list, ncol = 3) + 
    patchwork::plot_annotation(
      title = "Coordinate Distributions Near Complexity Transitions",
      subtitle = "Automatically Detected Transitions in Median Complexity from Changes in Momentum",
      theme = ggplot2::theme(
        plot.title = ggplot2::element_text(hjust = 0.5, face = "bold", size = 14, family = "mono"),
        plot.subtitle = ggplot2::element_text(hjust = 0.5, size = 10, family = "mono", color = "black")
      )
    )
}
```

```{r subset-config, echo=FALSE}
# --- SINGLE SOURCE OF TRUTH ---
max_rows      <- 100
subset_idx    <- 1:min(length(jumps), max_rows)
subset_jumps  <- jumps[subset_idx]
dynamic_h     <- 3 * length(subset_jumps)
```

```{r distributions-for-manuscript, fig.width=10, fig.height=dynamic_h, echo=FALSE}
# Now fig.height is dynamically tied to the actual number of rows
subset_plot <- generate_physics_grid(subset_jumps)

# Display in the Readme
subset_plot

# Save PDF with exact same dimensions
ggplot2::ggsave(
  filename = file.path(manuscript_dir, "distributions.pdf"),
  plot   = subset_plot, 
  width  = 10, 
  height = dynamic_h
)
```

# Ellipse Parameterization (A = PQ)

This visualization shows two overlapping ellipses centered at (0,0) where $A = PQ$. 

```{r experimental_ellipses, fig.width=10, fig.height=3 * length(jumps), echo=FALSE}
# 1. Extract and format labels with 2-decimal precision
ellipse_data <- lapply(jumps, function(j) {
  data.frame(
    transition_name = j$n,
    P_value = j$p_vals,
    Q_value = j$p_vals,
    p_label = factor(sprintf("P = Q = %.2f", j$p_vals), 
                     levels = sprintf("P = Q = %.2f", j$p_vals))
  )
}) %>% bind_rows()

# 2. Calculate radii and axis limits
plot_ready <- ellipse_data %>%
  mutate(
    q_radius_x = Q_value,
    q_radius_y = 1/P_value,
    p_radius_x = 1/Q_value,
    p_radius_y = P_value,
    lim = pmax(q_radius_x, p_radius_y) * 1.1 
  ) %>%
  pivot_longer(
    cols = starts_with("q_radius") | starts_with("p_radius"),
    names_to = c("ellipse_type", ".value"),
    names_pattern = "(.*)_radius_(.*)"
  )

# 3. Generate the plot object
ellipse_plot <- ggplot(plot_ready) +
  # Reduced linewidth for better resolution at high P, Q values
  geom_ellipse(aes(x0 = 0, y0 = 0, a = x, b = y, angle = 0, 
                   fill = ellipse_type, color = ellipse_type), 
               linewidth = 0.2, alpha = 0.5) +
  geom_blank(aes(x = lim, y = lim)) +
  geom_blank(aes(x = -lim, y = -lim)) +
  facet_wrap(transition_name ~ p_label, 
             scales = "free", 
             ncol = 3) +
  scale_fill_manual(values = c("q" = "black", "p" = "gray40"),
                    labels = c("q" = "Q", "p" = "P")) +
  scale_color_manual(values = c("q" = "black", "p" = "gray40"),
                     labels = c("q" = "Q", "p" = "P")) +
  labs(
    x = "q [q_0]",
    y = "p [p_0]",
    fill = "Conjugate Pair",
    color = "Conjugate Pair",

    
        title = "Conjugate Quanta of Action",
          subtitle = "LOWER PLATEAU, TRANSITION, UPPER PLATEAU",
  ) +
  theme_minimal() +
  theme(
    aspect.ratio = 1,
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 8)
  )

# Print the plot to the Rmd output
ellipse_plot

# 4. Save the plot to the manuscripts directory
num_transitions <- length(unique(ellipse_data$transition_name))
dynamic_h <- num_transitions * 3

ggplot2::ggsave(
  filename = here::here(manuscript_dir, "conjugate_quanta.pdf"),
  plot   = ellipse_plot, 
  width  = 10, 
  height = dynamic_h
)
```
