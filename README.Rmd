---
title: "Stern-Brocot Physics"
output:
  github_document: default
---

# Stern-Brocot Physics

## Quantum Harmonic Oscillator

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = here::here())
knitr::opts_chunk$set(fig.showtext = TRUE, dpi = 300)
library(ggplot2)
library(patchwork)
library(ggforce)
library(dplyr)
library(tidyr)
library(data.table)
```

```{r build-and-load, echo=F, message=F, include=F}
pkgbuild::compile_dll() 
devtools::load_all(".")

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  warning = FALSE,
  message = FALSE,
  fig.crop = TRUE
)
manuscript_dir <- here::here("manuscript")
```

```{r helper-functions-qho, echo=FALSE}
# --- CONSOLIDATED HELPER FUNCTIONS ---

# File path helper
get_histogram_path <- function(momentum_val) {
  here::here("data-raw", "outputs", "02_quantum_harmonic_oscillator", "histograms", 
             sprintf("histogram_P_%013.6f.csv.gz", round(momentum_val, 6)))
}

# Standardized save function
save_plot <- function(plot_obj, filename, width = 10, height = 6) {
  ggplot2::ggsave(
    filename = file.path(manuscript_dir, filename),
    plot = plot_obj, 
    width = width, 
    height = height,
    device = grDevices::cairo_pdf,
    limitsize = FALSE
  )
}

# Data preparation helper
prepare_plot_data <- function(dt_summary) {
  plot_data <- dt_summary[max_momentum > 0.0, .(
    p_val = as.numeric(max_momentum), 
    nodes = as.numeric(node_count)
  )]
  plot_data[, is_eigenstate := (floor(p_val / pi) == nodes)]
  return(plot_data)
}

# Median selection helper
get_median_by_nodes <- function(dt, node_col = "nodes", p_col = "p_val") {
  data.table::setorderv(dt, c(node_col, p_col))
  dt[dt[, .I[floor((.N+1)/2)], by = node_col]$V1][, 
     .(n = nodes, momentum = p_val)]
}

# Unified plot generation function
generate_plot_grid <- function(target_data, plot_title, file_name, show_placeholders = FALSE) {
  cols <- 3
  plot_storage <- vector("list", nrow(target_data))
  
  for (i in seq_len(nrow(target_data))) {
    cur_n <- target_data$n[i]
    cur_p <- target_data$momentum[i]
    
    # Handle placeholders for inaccessible states
    if (is.na(cur_p) && show_placeholders) {
      plot_storage[[i]] <- ggplot2::ggplot() + 
        ggplot2::annotate("text", x = 0.5, y = 0.5, 
                          label = paste0("n = ", cur_n, "\nNon-Schrödinger\nEigenstate"),
                          family = "mono", fontface = "italic", size = 3, color = "red") +
        ggplot2::theme_void() +
        ggplot2::theme(panel.background = ggplot2::element_rect(fill = "grey98", color = "grey90"))
      next
    }
    
    if (is.na(cur_p)) next

    f_path <- get_histogram_path(cur_p)

    if (file.exists(f_path)) {
      d_temp <- data.table::fread(f_path)
      h_pts <- d_temp[type == "hist"]
      n_pts <- d_temp[type == "node"]
      bw <- if(nrow(h_pts) > 1) diff(h_pts$x[1:2]) else 0.1

      plot_storage[[i]] <- ggplot2::ggplot(h_pts, ggplot2::aes(x, y)) +
        ggplot2::geom_col(fill = "black", alpha = 0.25, width = bw) +
        ggplot2::geom_point(data = n_pts, size = 1.2, shape = 16) +
        ggplot2::labs(title = paste0("n=", cur_n, " | P=", round(cur_p, 3)), x = "q", y = "") +
        ggplot2::theme_minimal(base_family = "mono")
    } else {
      plot_storage[[i]] <- ggplot2::ggplot() + ggplot2::theme_void() +
                           ggplot2::labs(title = paste("File Missing n=", cur_n))
    }
  }

  combined <- patchwork::wrap_plots(plot_storage, ncol = cols) + 
              patchwork::plot_annotation(title = plot_title)
              
  height_inches <- ceiling(nrow(target_data) / cols) * 3
  save_plot(combined, file_name, width = 10, height = height_inches)
  
  return(list(plot_object = combined, dynamic_height = height_inches))
}

# Physics grid for transitions
generate_physics_grid <- function(jumps_subset) {
  num_jumps <- length(jumps_subset)
  plot_list <- vector("list", num_jumps * 3)
  counter <- 1

  for (j in seq_len(num_jumps)) {
    for (p in seq_along(jumps_subset[[j]]$p_vals)) {
      current_p <- jumps_subset[[j]]$p_vals[p]
      f_path <- get_histogram_path(current_p)

      if (file.exists(f_path)) {
        combined_dt <- data.table::fread(f_path)
        node_label <- as.character(combined_dt$node_count[1])
        hist_data <- combined_dt[type == "hist"]
        node_data <- combined_dt[type == "node"]
        b_width <- if(nrow(hist_data) > 1) diff(hist_data$x[1:2]) else 0.1

        p_obj <- ggplot2::ggplot(hist_data, ggplot2::aes(x = x, y = y)) +
          ggplot2::geom_vline(xintercept = 0, color = "grey80", linetype = "dashed", linewidth = 0.4) +
          ggplot2::geom_col(fill = "black", alpha = 0.25, width = b_width) +
          ggplot2::geom_step(direction = "hv", color = "black", linewidth = 0.3) +
          ggplot2::geom_point(data = node_data, color = "black", size = 1.2, shape = 16) +
          ggplot2::labs(
            title = paste0(jumps_subset[[j]]$n, " Nodes: ", node_label, " at P = ", sprintf("%.2f", current_p)), 
            x = "q", y = ""
          ) +
          ggplot2::theme_minimal(base_family = "mono") +
          ggplot2::theme(
            plot.title = ggplot2::element_text(size = 9, face = "bold"),
            panel.grid.minor = ggplot2::element_blank()
          )
      } else {
        p_obj <- ggplot2::ggplot() + ggplot2::theme_void() + 
          ggplot2::annotate("text", x = 0.5, y = 0.5, 
                            label = paste("P =", sprintf("%.2f", current_p), "\nmissing"),
                            family = "mono", size = 3)
      }
      
      plot_list[[counter]] <- p_obj
      counter <- counter + 1
    }
  }

  patchwork::wrap_plots(plot_list, ncol = 3) + 
    patchwork::plot_annotation(
      title = "Coordinate Distributions Near Complexity Transitions",
      subtitle = "Automatically Detected Transitions in Median Complexity from Changes in Momentum",
      theme = ggplot2::theme(
        plot.title = ggplot2::element_text(hjust = 0.5, face = "bold", size = 14, family = "mono"),
        plot.subtitle = ggplot2::element_text(hjust = 0.5, size = 10, family = "mono", color = "black")
      )
    )
}
```

```{r jump-detection, echo=F}
summary_path <- here::here("data-raw", "outputs", "02_quantum_harmonic_oscillator", "02_quantum_harmonic_oscillator.csv.gz")
dt_summary <- data.table::fread(summary_path)
data.table::setorder(dt_summary, max_momentum)
dt_summary <- dt_summary[max_momentum > 0.0]

z_diffs <- abs(diff(dt_summary$kolmogorov_complexity_median))
threshold <- max(z_diffs, na.rm = TRUE) * 0.0001
jump_indices <- which(z_diffs > threshold)

jumps <- lapply(seq_along(jump_indices), function(i) {
  idx <- jump_indices[i]
  m_at <- dt_summary$max_momentum[idx + 1]
  list(
    n = paste("Transition", i),
    p_vals = c(m_at-1, m_at, m_at+1)
  )
})

p_markers <- dt_summary$max_momentum[jump_indices]
```

```{r introduction, child = 'inst/readme/introduction.Rmd'}
```

```{r dual-aspect-complexity, echo=FALSE, fig.width=12, fig.height=6}
plot_dt_q <- dt_summary[max_momentum > 0.0, .(
  q_val = 1 / as.numeric(max_momentum),
  y_mean = as.numeric(kolmogorov_complexity_mean),
  y_med = as.numeric(kolmogorov_complexity_median),
  y_sd = as.numeric(kolmogorov_complexity_sd)
)]

plot_dt_p <- dt_summary[max_momentum > 0.0, .(
  p_val = as.numeric(max_momentum),
  y_mean = as.numeric(kolmogorov_complexity_mean),
  y_med = as.numeric(kolmogorov_complexity_median),
  y_sd = as.numeric(kolmogorov_complexity_sd)
)]

p_spatial <- ggplot(plot_dt_q, aes(x = q_val)) +
  geom_vline(xintercept = 1/p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_ribbon(aes(ymin = y_mean - y_sd, ymax = y_mean + y_sd), fill = "gray50", alpha = 0.1) +
  geom_line(aes(y = y_mean, color = "Mean"), linewidth = 0.6) +
  geom_line(aes(y = y_med, color = "Median"), linewidth = 1.0) +
  scale_x_log10() +
  scale_color_manual(values = c("Mean" = "gray60", "Median" = "black")) +
  labs(
    title = latex2exp::TeX("Coordinate Complexity: $K(Q_0)$ vs. $Q$ (Log Scale)"),
    x = latex2exp::TeX("Coordinate $Q = 1/P$ [$q/q_0$]"),
    y = "Complexity [bits]",
    color = "Series"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5))

p_momentum <- ggplot(plot_dt_p, aes(x = p_val)) +
  geom_vline(xintercept = p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_ribbon(aes(ymin = y_mean - y_sd, ymax = y_mean + y_sd), fill = "gray50", alpha = 0.1) +
  geom_line(aes(y = y_mean, color = "Mean"), linewidth = 0.6) +
  geom_line(aes(y = y_med, color = "Median"), linewidth = 1.0) +
  scale_color_manual(values = c("Mean" = "gray60", "Median" = "black")) +
  labs(
    title = latex2exp::TeX("Momentum Complexity: $K(P_0)$ vs. $P$"),
    x = latex2exp::TeX("Momentum P [$p/p_0$]"),
    y = "Complexity [bits]",
    color = "Series"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5))

combined_blob_plot <- gridExtra::arrangeGrob(
  p_spatial, p_momentum, 
  ncol = 2,
  top = grid::textGrob("Coordinate and Momentum Complexity", 
                       gp = grid::gpar(fontsize = 16, font = 2))
)

grid::grid.draw(combined_blob_plot)
save_plot(combined_blob_plot, "complexity.pdf", width = 12, height = 6)
```

```{r dual-aspect-node-count, echo=FALSE, fig.width=12, fig.height=6}
plot_nodes_q <- dt_summary[max_momentum > 0.0, .(
  q_val = 1 / as.numeric(max_momentum),
  nodes = as.numeric(node_count)
)]

plot_nodes_p <- dt_summary[max_momentum > 0.0, .(
  p_val = as.numeric(max_momentum),
  nodes = as.numeric(node_count)
)]

p_nodes_spatial <- ggplot(plot_nodes_q, aes(x = q_val, y = nodes)) +
  geom_vline(xintercept = 1/p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_point(size = 0.2, alpha = 0.6, color = "black") +
  scale_x_log10() +
  labs(
    title = latex2exp::TeX("Coordinate Node Counts: Nodes vs. $Q$ (Log Scale)"),
    x = latex2exp::TeX("Coordinate $Q = 1/P$ [$q/q_0$]"),
    y = "Node Count [count]"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

p_nodes_momentum <- ggplot(plot_nodes_p, aes(x = p_val, y = nodes)) +
  geom_vline(xintercept = p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_point(size = 0.2, alpha = 0.6, color = "black") +
  labs(
    title = latex2exp::TeX("Momentum Node Counts: Nodes vs. $P$"),
    x = latex2exp::TeX("Momentum P [$p/p_0$]"),
    y = "Node Count [count]"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

combined_nodes_plot <- gridExtra::arrangeGrob(
  p_nodes_spatial, p_nodes_momentum, 
  ncol = 2,
  top = grid::textGrob("Coordinate and Momentum Node Counts", 
                       gp = grid::gpar(fontsize = 16, font = 2))
)

grid::grid.draw(combined_nodes_plot)
save_plot(combined_nodes_plot, "nodes.pdf", width = 12, height = 6)
```

```{r prepare-eigenstate-data, echo=FALSE}
# Prepare all eigenstate and median data once
plot_nodes_p <- prepare_plot_data(dt_summary)
max_n_found <- max(plot_nodes_p$nodes, na.rm = TRUE)

# Full collection median
dt_full_median <- get_median_by_nodes(plot_nodes_p)

# Eigenstate collection with gaps
dt_eigen_raw <- plot_nodes_p[is_eigenstate == TRUE]
dt_eigen_subset <- get_median_by_nodes(dt_eigen_raw)
dt_eigen_median <- data.table::data.table(n = 0:max_n_found)
dt_eigen_median <- merge(dt_eigen_median, dt_eigen_subset, by = "n", all.x = TRUE)
```

```{r filter-valid-eigenstates, echo=FALSE, fig.width=8, fig.height=6}
p_momentum_filtered <- ggplot(plot_nodes_p, aes(x = p_val, y = nodes)) +
  geom_point(color = "grey70", size = 0.2, alpha = 0.4) +
  geom_vline(xintercept = p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_point(data = plot_nodes_p[is_eigenstate == TRUE], color = "red", size = 0.3) +
  labs(
    title = latex2exp::TeX("Schrödinger Eigenstates (red) Among All Configurations"),
    subtitle = "Eigenstates are vanishingly sparse configurations among expanding possibilities in phase space.",
    x = latex2exp::TeX("Momentum P [$p/p_0$]"),
    y = latex2exp::TeX("Node Count (Coordinate $Q$ Distributions)"),
    caption = "Red: Eigenstates | Grey: All Configurations"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10, face = "italic"),
    axis.title = element_text(size = 11)
  )

print(p_momentum_filtered)
save_plot(p_momentum_filtered, "eigenstates.pdf", width = 8, height = 6)
```

```{r generate-eigenstate-plots, echo=FALSE}
render_full <- generate_plot_grid(dt_full_median, "Full Distribution Sequence", "all_nodes_median.pdf")
render_eigen <- generate_plot_grid(dt_eigen_median, "Eigenstate Distribution Sequence (Showing Inaccessible Gaps)", "eigen_nodes_gaps.pdf", show_placeholders = TRUE)
```

```{r plot-eigen-grid, echo=FALSE, fig.width=10, fig.height=render_eigen$dynamic_height}
render_eigen$plot_object
```

```{r momentum-counts-histogram, echo=FALSE, fig.width=10, fig.height=6}
momentum_counts <- dt_summary[max_momentum > 0.0, .(Count = .N), by = .(n = as.integer(node_count))]

ggplot2::ggplot(momentum_counts, ggplot2::aes(x = n, y = Count)) +
  ggplot2::geom_col(fill = "steelblue", color = "black", alpha = 0.8) +
  ggplot2::labs(
    title = "Data Availability: Count of Momentum Values per Quantum Number (n)",
    x = "Quantum Number (Node Count)",
    y = "Number of Data Points (Momentum entries)"
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, face = "bold"))
```

```{r plot-median-distribution, echo=FALSE, fig.width=8, fig.height=6}
plot_nodes_p[, is_median := FALSE]
plot_nodes_p[dt_full_median, on = .(nodes = n, p_val = momentum), is_median := TRUE]

p_median_highlighted <- ggplot(plot_nodes_p, aes(x = p_val, y = nodes)) +
  geom_point(color = "grey70", size = 0.2, alpha = 0.4) +
  geom_vline(xintercept = p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_point(data = plot_nodes_p[is_median == TRUE], color = "blue", size = 0.3) +
  labs(
    title = latex2exp::TeX("Median Configurations (blue) Across Node Counts"),
    subtitle = "Highlighting the lower-median momentum P for each node count n.",
    x = latex2exp::TeX("Momentum P [$p/p_0$]"),
    y = latex2exp::TeX("Node Count (Coordinate $Q$ Distributions)"),
    caption = "Blue: Selected Medians | Grey: All Configurations"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10, face = "italic"),
    axis.title = element_text(size = 11)
  )

print(p_median_highlighted)
save_plot(p_median_highlighted, "median_distribution.pdf", width = 8, height = 6)
```

```{r plot-full-grid, echo=FALSE, fig.width=10, fig.height=render_full$dynamic_height}
render_full$plot_object
```

```{r subset-config, echo=FALSE}
max_rows <- 300
subset_idx <- 1:min(length(jumps), max_rows)
subset_jumps <- jumps[subset_idx]
dynamic_h <- 3 * length(subset_jumps)
```

```{r distributions-for-manuscript, fig.width=10, fig.height=dynamic_h, echo=FALSE}
subset_plot <- generate_physics_grid(subset_jumps)
subset_plot
save_plot(subset_plot, "distributions.pdf", width = 10, height = dynamic_h)
```

# Ellipse Parameterization (A = PQ)

This visualization shows two overlapping ellipses centered at (0,0) where $A = PQ$. 

```{r experimental_ellipses, fig.width=10, fig.height=3 * length(jumps), echo=FALSE}
ellipse_data <- lapply(jumps, function(j) {
  data.frame(
    transition_name = j$n,
    P_value = j$p_vals,
    Q_value = j$p_vals,
    p_label = factor(sprintf("P = Q = %.2f", j$p_vals), 
                     levels = sprintf("P = Q = %.2f", j$p_vals))
  )
}) %>% bind_rows()

plot_ready <- ellipse_data %>%
  mutate(
    q_radius_x = Q_value,
    q_radius_y = 1/P_value,
    p_radius_x = 1/Q_value,
    p_radius_y = P_value,
    lim = pmax(q_radius_x, p_radius_y) * 1.1 
  ) %>%
  pivot_longer(
    cols = starts_with("q_radius") | starts_with("p_radius"),
    names_to = c("ellipse_type", ".value"),
    names_pattern = "(.*)_radius_(.*)"
  )

ellipse_plot <- ggplot(plot_ready) +
  geom_ellipse(aes(x0 = 0, y0 = 0, a = x, b = y, angle = 0, 
                   fill = ellipse_type, color = ellipse_type), 
               linewidth = 0.2, alpha = 0.5) +
  geom_blank(aes(x = lim, y = lim)) +
  geom_blank(aes(x = -lim, y = -lim)) +
  facet_wrap(transition_name ~ p_label, scales = "free", ncol = 3) +
  scale_fill_manual(values = c("q" = "black", "p" = "gray40"),
                    labels = c("q" = "Q", "p" = "P")) +
  scale_color_manual(values = c("q" = "black", "p" = "gray40"),
                     labels = c("q" = "Q", "p" = "P")) +
  labs(
    x = "q [q_0]",
    y = "p [p_0]",
    fill = "Conjugate Pair",
    color = "Conjugate Pair",
    title = "Conjugate Quanta of Action",
    subtitle = "LOWER PLATEAU, TRANSITION, UPPER PLATEAU"
  ) +
  theme_minimal() +
  theme(
    aspect.ratio = 1,
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 8)
  )

ellipse_plot

num_transitions <- length(unique(ellipse_data$transition_name))
dynamic_h_ellipse <- num_transitions * 3
save_plot(ellipse_plot, "conjugate_quanta.pdf", width = 10, height = dynamic_h_ellipse)
```

## Particle in a Box

```{r helper-functions-pib, echo=FALSE}
# --- HELPER FUNCTIONS FOR PIB ---

# File path helper
get_histogram_path <- function(momentum_val) {
  here::here("data-raw", "outputs", "03_particle_in_a_box", "histograms", 
             sprintf("histogram_P_%013.6f.csv.gz", round(momentum_val, 6)))
}

# Standardized save function
save_plot <- function(plot_obj, filename, width = 10, height = 6) {
  ggplot2::ggsave(
    filename = file.path(manuscript_dir, filename),
    plot = plot_obj, 
    width = width, 
    height = height,
    device = grDevices::cairo_pdf,
    limitsize = FALSE
  )
}

# Data preparation helper
prepare_plot_data <- function(dt_summary) {
  plot_data <- dt_summary[max_momentum > 0.0, .(
    p_val = as.numeric(max_momentum), 
    nodes = as.numeric(node_count)
  )]
  # PIB eigenstates: n = floor(P/pi) for sine waves in box
  plot_data[, is_eigenstate := (floor(p_val / pi) == nodes)]
  return(plot_data)
}

# Median selection helper
get_median_by_nodes <- function(dt, node_col = "nodes", p_col = "p_val") {
  data.table::setorderv(dt, c(node_col, p_col))
  dt[dt[, .I[floor((.N+1)/2)], by = node_col]$V1][, 
     .(n = nodes, momentum = p_val)]
}
```

```{r load-data, echo=FALSE}
summary_path <- here::here("data-raw", "outputs", "03_particle_in_a_box", "03_aggregated_summary.csv.gz")
dt_summary <- data.table::fread(summary_path)
data.table::setorder(dt_summary, max_momentum)
dt_summary <- dt_summary[max_momentum > 0.0]

# Detect complexity transitions
z_diffs <- abs(diff(dt_summary$kolmogorov_complexity_median))
threshold <- max(z_diffs, na.rm = TRUE) * 0.0001
jump_indices <- which(z_diffs > threshold)

jumps <- lapply(seq_along(jump_indices), function(i) {
  idx <- jump_indices[i]
  m_at <- dt_summary$max_momentum[idx + 1]
  list(
    n = paste("Transition", i),
    p_vals = c(m_at-1, m_at, m_at+1)
  )
})

p_markers <- dt_summary$max_momentum[jump_indices]
```

# Particle in a Box Analysis

The particle in a box has a fixed spatial extent L=1, but momentum can increase indefinitely. Unlike the quantum harmonic oscillator where both P and Q scale together, here the coordinate remains bounded while momentum grows.

## Complexity vs Momentum

```{r complexity-plot, echo=FALSE, fig.width=12, fig.height=6}
plot_dt_p <- dt_summary[max_momentum > 0.0, .(
  p_val = as.numeric(max_momentum),
  y_mean = as.numeric(kolmogorov_complexity_mean),
  y_med = as.numeric(kolmogorov_complexity_median),
  y_sd = as.numeric(kolmogorov_complexity_sd)
)]

p_complexity <- ggplot(plot_dt_p, aes(x = p_val)) +
  geom_vline(xintercept = p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_ribbon(aes(ymin = y_mean - y_sd, ymax = y_mean + y_sd), fill = "gray50", alpha = 0.1) +
  geom_line(aes(y = y_mean, color = "Mean"), linewidth = 0.6) +
  geom_line(aes(y = y_med, color = "Median"), linewidth = 1.0) +
  scale_color_manual(values = c("Mean" = "gray60", "Median" = "black")) +
  labs(
    title = "PIB: Kolmogorov Complexity vs. Momentum",
    x = "Momentum P [p/p_0]",
    y = "Complexity [bits]",
    color = "Series"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5))

print(p_complexity)
save_plot(p_complexity, "pib_complexity.pdf", width = 12, height = 6)
```

## Node Count vs Momentum

```{r node-count-plot, echo=FALSE, fig.width=10, fig.height=6}
plot_nodes_p <- dt_summary[max_momentum > 0.0, .(
  p_val = as.numeric(max_momentum),
  nodes = as.numeric(node_count)
)]

p_nodes <- ggplot(plot_nodes_p, aes(x = p_val, y = nodes)) +
  geom_vline(xintercept = p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_point(size = 0.3, alpha = 0.6, color = "black") +
  labs(
    title = "PIB: Node Counts vs. Momentum",
    x = "Momentum P [p/p_0]",
    y = "Node Count"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

print(p_nodes)
save_plot(p_nodes, "pib_nodes.pdf", width = 10, height = 6)
```

## Eigenstate Identification

```{r eigenstates-plot, echo=FALSE, fig.width=10, fig.height=6}
plot_nodes_p <- prepare_plot_data(dt_summary)

p_eigenstates <- ggplot(plot_nodes_p, aes(x = p_val, y = nodes)) +
  geom_point(color = "grey70", size = 0.2, alpha = 0.4) +
  geom_vline(xintercept = p_markers, color = "grey80", linetype = "dashed", alpha = 0.5) +
  geom_point(data = plot_nodes_p[is_eigenstate == TRUE], color = "red", size = 0.4) +
  labs(
    title = "PIB: Eigenstates (red) Among All Configurations",
    subtitle = "For particle in a box with L=1, eigenstates follow n = floor(P/π)",
    x = "Momentum P [p/p_0]",
    y = "Node Count",
    caption = "Red: Eigenstates | Grey: All Configurations"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10, face = "italic")
  )

print(p_eigenstates)
save_plot(p_eigenstates, "pib_eigenstates.pdf", width = 10, height = 6)
```

## Sample Coordinate Distributions

```{r sample-distributions, echo=FALSE, fig.width=10, fig.height=12}
# Select a range of momentum values to visualize
sample_momenta <- dt_summary[seq(1, nrow(dt_summary), length.out = min(12, nrow(dt_summary))), max_momentum]

plot_list <- vector("list", length(sample_momenta))

for (i in seq_along(sample_momenta)) {
  p_val <- sample_momenta[i]
  f_path <- get_histogram_path(p_val)
  
  if (file.exists(f_path)) {
    d_temp <- fread(f_path)
    h_pts <- d_temp[type == "hist"]
    n_pts <- d_temp[type == "node"]
    node_count <- d_temp$node_count[1]
    
    plot_list[[i]] <- ggplot(h_pts, aes(x, y)) +
      # Use geom_area and geom_line for a smoother visual representation
      # This connects midpoints, blurring high frequencies into the classical uniform PDF
      geom_area(fill = "steelblue", alpha = 0.3) +
      geom_line(color = "steelblue", linewidth = 0.5) +
      geom_point(data = n_pts, size = 1.5, shape = 16, color = "red") +
      labs(
        title = sprintf("P=%.2f | n=%d", p_val, node_count),
        x = "q [position in box]", 
        y = "counts"
      ) +
      theme_minimal(base_family = "mono") +
      theme(plot.title = element_text(size = 9))
  } else {
    plot_list[[i]] <- ggplot() + 
      theme_void() +
      labs(title = sprintf("P=%.2f missing", p_val))
  }
}

combined <- patchwork::wrap_plots(plot_list, ncol = 3) +
  patchwork::plot_annotation(
    title = "Particle in a Box: Coordinate Distributions at Various Momenta",
    subtitle = "Fixed box length L=1, increasing momentum P"
  )

print(combined)
save_plot(combined, "pib_distributions_sample.pdf", width = 10, height = 12)

```

## Low vs High Momentum Comparison

```{r low-high-comparison, echo=FALSE, fig.width=12, fig.height=4}
# Compare low, medium, and high momentum states
low_p <- dt_summary[1, max_momentum]
mid_p <- dt_summary[nrow(dt_summary) %/% 2, max_momentum]
high_p <- dt_summary[nrow(dt_summary), max_momentum]

compare_momenta <- c(low_p, mid_p, high_p)
compare_plots <- vector("list", 3)

for (i in 1:3) {
  p_val <- compare_momenta[i]
  f_path <- get_histogram_path(p_val)
  
  if (file.exists(f_path)) {
    d_temp <- fread(f_path)
    h_pts <- d_temp[type == "hist"]
    n_pts <- d_temp[type == "node"]
    node_count <- d_temp$node_count[1]
    # No longer need bw for geom_line/geom_area
    # bw <- if(nrow(h_pts) > 1) diff(h_pts$x[1:2]) else 0.1
    
    compare_plots[[i]] <- ggplot(h_pts, aes(x, y)) +
      # Use geom_area and geom_line here as well
      geom_area(fill = "steelblue", alpha = 0.3) +
      geom_line(color = "black", linewidth = 0.5) +
      geom_point(data = n_pts, size = 2, shape = 16, color = "red") +
      labs(
        title = sprintf("P=%.2f (n=%d)", p_val, node_count),
        x = "q", 
        y = ""
      ) +
      theme_minimal(base_family = "mono") +
      theme(plot.title = element_text(size = 10, face = "bold"))
  }
}

comparison <- patchwork::wrap_plots(compare_plots, ncol = 3) +
  patchwork::plot_annotation(
    title = "PIB: Low, Medium, and High Momentum States",
    subtitle = "Note: coordinate range remains fixed at box length L=1"
  )

print(comparison)
save_plot(comparison, "pib_momentum_comparison.pdf", width = 12, height = 4)
```
